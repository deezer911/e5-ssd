"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeTypeFromSchema = exports.removeQueryMutationFromSchema = exports.mergeTypeIntoSchema = exports.mergeQueryMutationIntoSchema = exports.getSchema = exports.getExtensions = exports.getConfiguration = exports.findTypeInSchema = exports.findQueryMutationInSchema = exports.findNextAvailableSubfolder = exports.dedupeTempFolder = void 0;
const graphql_1 = require("graphql");
const utilities_1 = require("graphql/utilities");
const node_fetch_1 = require("node-fetch");
const fs = require("fs-extra");
const glob = require("glob");
const os = require("os");
const path = require("path");
const lodash_1 = require("lodash");
const graphql_helpers_1 = require("../utils/graphql-helpers");
const constants_1 = require("./constants");
const configure_1 = require("../actions/configure");
const transpile_1 = require("../actions/transpile");
const dedupeTempFolder = (dirpath) => {
    do {
        dirpath = lodash_1.replace(dirpath, os.tmpdir(), '');
    } while (dirpath.includes(os.tmpdir()));
    dirpath = path.join(os.tmpdir(), dirpath);
    return dirpath;
};
exports.dedupeTempFolder = dedupeTempFolder;
const findNextAvailableSubfolder = (folder, name) => {
    let subfolder = name;
    let counter = 1;
    while (fs.existsSync(path.join(folder, subfolder))) {
        const suffix = `${counter++}`.padStart(2, '0');
        subfolder = `${name}-${suffix}`;
    }
    return subfolder;
};
exports.findNextAvailableSubfolder = findNextAvailableSubfolder;
const findQueryMutationInSchema = (name, files) => {
    for (const file of files) {
        let found = false;
        graphql_1.visit(file.ast, {
            FieldDefinition(node) {
                if (node.name.value === name) {
                    found = true;
                    return graphql_1.BREAK;
                }
            },
        });
        if (found)
            return true;
    }
    return false;
};
exports.findQueryMutationInSchema = findQueryMutationInSchema;
const findTypeInSchema = (name, files) => {
    for (const file of files) {
        let found = false;
        graphql_1.visit(file.ast, {
            ObjectTypeDefinition(node) {
                if (node.name.value === name) {
                    found = true;
                    return graphql_1.BREAK;
                }
            },
        });
        if (found)
            return true;
    }
    return false;
};
exports.findTypeInSchema = findTypeInSchema;
const getConfiguration = async (directories, silent = false, answers = {}) => {
    const tmp = path.join(os.tmpdir(), `stepzen-tmp-config-${Date.now()}`);
    fs.ensureDirSync(tmp);
    for (const directory of directories) {
        const configs = [
            ...glob.sync('**/config.yaml', { cwd: directory }),
            ...glob.sync('**/stepzen.config.json', { cwd: directory }),
        ];
        for (const config of configs) {
            const configFolder = path.join(directory, config);
            let writeFolder = path.join(tmp, directory, config);
            writeFolder = exports.dedupeTempFolder(writeFolder);
            const content = fs.readFileSync(configFolder, 'utf8');
            fs.ensureFileSync(writeFolder);
            fs.writeFileSync(writeFolder, content);
        }
    }
    const configuration = await configure_1.default(tmp, silent, answers);
    fs.removeSync(tmp);
    return configuration;
};
exports.getConfiguration = getConfiguration;
const getExtensions = async () => {
    const domain = constants_1.STEPZEN_DOMAIN.replace('.io', '.net');
    const response = await node_fetch_1.default(`https://www.${domain}/directives.graphql`);
    const text = await response.text();
    return text;
};
exports.getExtensions = getExtensions;
const getSchema = async (directory) => {
    const extensions = await exports.getExtensions();
    const transpiled = await transpile_1.default(directory);
    return utilities_1.buildSchema(`${extensions}${os.EOL}${transpiled.schema}`);
};
exports.getSchema = getSchema;
const mergeQueryMutationIntoSchema = (type, files) => {
    files = files.map((file) => {
        return Object.assign(Object.assign({}, file), { ast: graphql_1.visit(file.ast, {
                FieldDefinition(node) {
                    if (node.name.value === type.name.value) {
                        const directives = graphql_helpers_1.cloneDeep(type.directives);
                        const mutated = graphql_helpers_1.cloneDeep(node);
                        mutated.directives = directives;
                        return mutated;
                    }
                },
            }) });
    });
    return files;
};
exports.mergeQueryMutationIntoSchema = mergeQueryMutationIntoSchema;
const mergeTypeIntoSchema = (type, files) => {
    files = files.map((file) => {
        return Object.assign(Object.assign({}, file), { ast: graphql_1.visit(file.ast, {
                ObjectTypeDefinition(node) {
                    if (node.name.value === type.name.value) {
                        const directives = graphql_helpers_1.cloneDeep(type.directives);
                        const fields = graphql_helpers_1.cloneDeep(type.fields);
                        const mutated = graphql_helpers_1.cloneDeep(node);
                        mutated.directives = directives;
                        mutated.fields = fields;
                        return mutated;
                    }
                },
            }) });
    });
    return files;
};
exports.mergeTypeIntoSchema = mergeTypeIntoSchema;
const removeQueryMutationFromSchema = (name, files) => {
    files = files.map((file) => {
        return Object.assign(Object.assign({}, file), { ast: graphql_1.visit(file.ast, {
                FieldDefinition(node) {
                    if (node.name.value === name) {
                        return null;
                    }
                },
            }) });
    });
    return files;
};
exports.removeQueryMutationFromSchema = removeQueryMutationFromSchema;
const removeTypeFromSchema = (name, files) => {
    files = files.map((file) => {
        return Object.assign(Object.assign({}, file), { ast: graphql_1.visit(file.ast, {
                ObjectTypeDefinition(node) {
                    if (node.name.value === name) {
                        return null;
                    }
                },
            }) });
    });
    return files;
};
exports.removeTypeFromSchema = removeTypeFromSchema;
//# sourceMappingURL=merge-helpers.js.map