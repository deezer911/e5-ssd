"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const graphql_1 = require("graphql");
const fs = require("fs-extra");
const glob = require("glob");
const os = require("os");
const path = require("path");
const prettier = require("prettier");
const dedupe_query_and_mutation_types_1 = require("../utils/dedupe-query-and-mutation-types");
exports.default = (source, output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`)) => {
    // Ensure source and output directories exist
    if (!fs.existsSync(source))
        throw new Error(`Cannot find source directory ${source}`);
    fs.ensureDirSync(output);
    // Get a list of files.
    let ast;
    let files = [];
    // If there's an index.graphQL - get files argument in @sdl directive
    const sourceIndex = path.join(source, 'index.graphql');
    if (fs.existsSync(sourceIndex)) {
        const index = fs.readFileSync(sourceIndex, 'utf8');
        ast = graphql_1.parse(index);
        ast = graphql_1.visit(ast, {
            Directive(node) {
                var _a;
                if (node.name.value === 'sdl') {
                    const list = (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'files');
                    // If we find a 'files' argument, we copy the list, and remove the argument
                    if (list) {
                        const copy = lodash_1.clone(list.value);
                        for (const file of copy.values) {
                            files = files.concat(file.value);
                        }
                        const mutated = lodash_1.cloneDeep(node);
                        mutated.arguments = mutated.arguments.filter((arg) => arg.name.value !== 'files');
                        return mutated;
                    }
                }
            },
        });
    }
    else {
        const content = glob
            .sync('**/*.graphql', { cwd: source })
            .map((file) => {
            const graphql = fs.readFileSync(`${source}/${file}`, 'utf8');
            return graphql;
        });
        ast = graphql_1.parse(content.join(os.EOL));
    }
    // Strip @sdl directive
    ast = graphql_1.visit(ast, {
        Directive(node) {
            if (node.name.value === 'sdl')
                return null;
        },
    });
    // Check all the files exist
    for (const file of files) {
        const find = path.join(source, file);
        if (!fs.existsSync(find)) {
            throw new Error(`Cannot find file ${find}`);
        }
    }
    // Get all the files and stitch
    const printed = graphql_1.print(ast);
    let stitched = `${printed}${os.EOL}`;
    for (const file of files) {
        const find = path.join(source, file);
        const content = fs.readFileSync(find, 'utf8');
        stitched += `${content}${os.EOL}`;
    }
    // Dedupe Query and Mutation types
    stitched = dedupe_query_and_mutation_types_1.default(stitched);
    // Format
    stitched = prettier.format(stitched, { parser: 'graphql' });
    // Write to output folder
    const outputIndex = path.join(output, 'index.graphql');
    fs.writeFileSync(outputIndex, stitched);
    // Copy config if exists, too
    const sourceConfig = path.join(source, 'config.yaml');
    const outputConfig = path.join(output, 'config.yaml');
    if (fs.existsSync(sourceConfig)) {
        fs.copyFileSync(sourceConfig, outputConfig);
    }
    // Return output folder
    return output;
};
//# sourceMappingURL=stitch.js.map