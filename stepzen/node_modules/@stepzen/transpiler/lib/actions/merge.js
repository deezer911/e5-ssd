"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const glob = require("glob");
const merge_1 = require("@graphql-tools/merge");
const graphql_1 = require("graphql");
const os = require("os");
const path = require("path");
const merge_helpers_1 = require("../utils/merge-helpers");
const print_1 = require("./print");
const set_files_in_sdl_1 = require("../utils/set-files-in-sdl");
const strip_empty_queries_and_mutations_1 = require("../utils/strip-empty-queries-and-mutations");
const BLANK_INDEX_TEMPLATE = `
schema @sdl(files: []) {
  query: Query
}
`.trim();
const BLANK_QUERY_TYPE = `
type Query {
  __query: String
}
`.trim();
exports.default = async (original, imported, options = {
    answers: {},
    output: null,
    silent: false,
    mergeTypes: true,
}) => {
    // Make sure there is an output directory
    if (!options.answers)
        options.answers = {};
    if (!options.output)
        options.output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`);
    if (!options.silent)
        options.silent = false;
    if (options.mergeTypes === undefined)
        options.mergeTypes = true;
    // To stop things like
    // C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-config-1638293497187\C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-1638293496286
    options.output = merge_helpers_1.dedupeTempFolder(options.output);
    // Ensure original, importing and output directories exist
    if (!fs.existsSync(original))
        throw new Error(`Cannot find original directory ${original}`);
    if (!fs.existsSync(imported.source))
        throw new Error(`Cannot find imported source directory ${imported.source}`);
    fs.ensureDirSync(options.output);
    // Copy the original into the output.
    fs.copySync(original, options.output);
    // Ensure an index.graphql exists
    const outputIndex = path.join(options.output, 'index.graphql');
    if (!fs.existsSync(outputIndex)) {
        fs.writeFileSync(outputIndex, options.mergeTypes
            ? // (2022-03-09, vluakshov) Not sure what'd break without the
                // blank Query type, but that's why I do not want to remove it
                // from the default code path.
                BLANK_INDEX_TEMPLATE + BLANK_QUERY_TYPE
            : // In the non-default code path that does NOT merge types
                // the blank Query type causes explicit problems
                // (https://github.com/steprz/stepzen-cli/issues/482).
                BLANK_INDEX_TEMPLATE);
    }
    const targetSubfolder = merge_helpers_1.findNextAvailableSubfolder(original, imported.name);
    if (options.mergeTypes) {
        const merged = merge_1.mergeTypeDefs([
            await merge_helpers_1.getSchema(options.output),
            await merge_helpers_1.getSchema(imported.source),
        ]);
        let queries = [];
        let mutations = [];
        let types = [];
        graphql_1.visit(merged, {
            ObjectTypeDefinition(node) {
                if (node.name.value === 'Query')
                    queries = queries.concat(node.fields);
                else if (node.name.value === 'Mutation')
                    mutations = mutations.concat(node.fields);
                else
                    types = types.concat(node);
            },
        });
        const details = {
            original: glob.sync('**/*.graphql', { cwd: options.output }).map(file => {
                const content = fs.readFileSync(`${options.output}/${file}`, 'utf8');
                return { ast: graphql_1.parse(content), file };
            }),
            imported: glob.sync('**/*.graphql', { cwd: imported.source }).map(file => {
                const content = fs.readFileSync(`${imported.source}/${file}`, 'utf8');
                return { ast: graphql_1.parse(content), file };
            }),
        };
        // Merge Queries and Mutations
        for (const type of [...queries, ...mutations]) {
            const isInOriginal = merge_helpers_1.findQueryMutationInSchema(type.name.value, details.original);
            const isInImported = merge_helpers_1.findQueryMutationInSchema(type.name.value, details.imported);
            if (isInOriginal && isInImported) {
                details.original = merge_helpers_1.mergeQueryMutationIntoSchema(type, details.original);
                details.imported = merge_helpers_1.removeQueryMutationFromSchema(type.name.value, details.imported);
            }
        }
        // Merge Types
        for (const type of types) {
            const isInOriginal = merge_helpers_1.findTypeInSchema(type.name.value, details.original);
            const isInImported = merge_helpers_1.findTypeInSchema(type.name.value, details.imported);
            if (isInOriginal && isInImported) {
                details.original = merge_helpers_1.mergeTypeIntoSchema(type, details.original);
                details.imported = merge_helpers_1.removeTypeFromSchema(type.name.value, details.imported);
            }
        }
        // Clean up the files. Remove empty Query / Mutation types, filter out now-empty files
        const cleaned = {
            original: details.original
                .map(item => (Object.assign(Object.assign({}, item), { ast: strip_empty_queries_and_mutations_1.default(item.ast) })))
                .filter(item => item.ast.definitions.length > 0),
            imported: details.imported
                .map(item => (Object.assign(Object.assign({}, item), { ast: strip_empty_queries_and_mutations_1.default(item.ast) })))
                .filter(item => item.ast.definitions.length > 0),
        };
        // Write the files to the output directory
        cleaned.original.forEach((a) => {
            // eslint-disable-next-line
            const file = path.join(options.output, a.file);
            const deduped = merge_helpers_1.dedupeTempFolder(file);
            fs.ensureFileSync(deduped);
            fs.writeFileSync(deduped, print_1.default(a.ast));
        });
        cleaned.imported.forEach(a => {
            // eslint-disable-next-line
            const file = path.join(options.output, targetSubfolder, a.file);
            const deduped = merge_helpers_1.dedupeTempFolder(file);
            fs.ensureFileSync(deduped);
            fs.writeFileSync(deduped, print_1.default(a.ast));
        });
    }
    else {
        // Write the files to the output directory
        fs.copySync(original, options.output);
        glob.sync('**/*.graphql', { cwd: imported.source }).forEach(relativePath => {
            const importedFullPath = path.join(imported.source, relativePath);
            const targetFullPath = path.join(options.output, targetSubfolder, relativePath);
            fs.ensureDirSync(path.dirname(targetFullPath));
            fs.copyFileSync(importedFullPath, targetFullPath);
        });
    }
    // Make sure all files are referenced in @sdl
    set_files_in_sdl_1.default(options.output);
    // Generate configuration
    const config = await merge_helpers_1.getConfiguration([options.output, imported.source], options.silent, options.answers);
    if (config) {
        const configFile = path.join(options.output, 'config.yaml');
        fs.writeFileSync(configFile, config);
    }
    // Return a merged schema!
    return options.output;
};
//# sourceMappingURL=merge.js.map