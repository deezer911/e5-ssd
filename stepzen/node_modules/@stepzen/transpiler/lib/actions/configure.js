"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const debug = require("debug");
const fs = require("fs-extra");
const glob = require("glob");
const inquirer = require("inquirer");
const path = require("path");
const yaml = require("yaml");
exports.default = async (source, silent = false, answers = {}) => {
    var e_1, _a, e_2, _b;
    var _c, _d, _e, _f;
    let config = {
        configurationset: [],
        ruleset: [],
    };
    // Now let's parse and add any config.yamls
    for (const y of glob.sync('**/config.yaml', { cwd: source })) {
        const filePath = path.join(source, y);
        const file = fs.readFileSync(filePath, 'utf8');
        const asYAML = yaml.parse(file);
        debug('stepzen:transpiler')(`Adding config.yaml ${filePath}`);
        debug('stepzen:transpiler')(`Contents: ${JSON.stringify(asYAML, null, 2)}`);
        if (asYAML.configurationset) {
            config.configurationset = config.configurationset.concat(asYAML.configurationset);
        }
        if (asYAML.ruleset) {
            config.ruleset = config.ruleset.concat(asYAML.ruleset);
        }
    }
    try {
        // Now let's build configs from questions
        for (var _g = tslib_1.__asyncValues(glob.sync('**/stepzen.config.json', {
            cwd: source,
        })), _h; _h = await _g.next(), !_h.done;) {
            const j = _h.value;
            const filePath = path.join(source, j);
            const file = fs.readFileSync(filePath, 'utf8');
            const asJSON = JSON.parse(file);
            debug('stepzen:transpiler')(`Adding stepzen.config.json ${filePath}`);
            debug('stepzen:transpiler')(`Contents: ${JSON.stringify(asJSON, null, 2)}`);
            if ((_c = asJSON.config) === null || _c === void 0 ? void 0 : _c.questions) {
                try {
                    for (var _j = (e_2 = void 0, tslib_1.__asyncValues((_d = asJSON.config) === null || _d === void 0 ? void 0 : _d.questions)), _k; _k = await _j.next(), !_k.done;) {
                        const question = _k.value;
                        const [name, key] = question.name.split('.');
                        let answer = {};
                        if (silent) {
                            answer = {
                                [name]: { [key]: ((_e = answers[name]) === null || _e === void 0 ? void 0 : _e[key]) ? (_f = answers[name]) === null || _f === void 0 ? void 0 : _f[key] : '' },
                            };
                        }
                        else {
                            answer = await inquirer.prompt(Object.assign({ type: 'password' }, question));
                        }
                        const configset = {
                            configuration: {
                                name,
                                [key]: answer[name][key],
                            },
                        };
                        debug('stepzen:transpiler')(`Question: ${JSON.stringify(question, null, 2)}`);
                        debug('stepzen:transpiler')(`Answer: ${JSON.stringify(configset, null, 2)}`);
                        config.configurationset.push(Object.assign({}, configset));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_k && !_k.done && (_b = _j.return)) await _b.call(_j);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_a = _g.return)) await _a.call(_g);
        }
        finally { if (e_1) throw e_1.error; }
    }
    debug('stepzen:transpiler')(`Configuration: ${JSON.stringify(config, null, 2)}`);
    // OK now let's collate everything into shared configurations
    const obj = {};
    for (const c of config.configurationset) {
        const name = c.configuration.name;
        if (!obj[name])
            obj[name] = {};
        for (const [key, value] of Object.entries(c.configuration)) {
            if (key === name)
                continue;
            obj[name][key] = value;
        }
    }
    // Now convert back into StepZen format
    const structured = {
        configurationset: [],
        ruleset: [],
    };
    for (const configuration of Object.keys(obj)) {
        structured.configurationset.push({
            configuration: Object.assign({}, obj[configuration]),
        });
    }
    structured.ruleset = [...config.ruleset];
    // Return YAML, if appropriate
    if (structured.configurationset.length === 0)
        delete structured.configurationset;
    if (structured.ruleset.length === 0)
        delete structured.ruleset;
    if (structured.configurationset || structured.ruleset) {
        return yaml.stringify(structured);
    }
    return false;
};
//# sourceMappingURL=configure.js.map