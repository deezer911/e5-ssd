import * as fs from 'fs-extra'
import * as glob from 'glob'
import {mergeTypeDefs} from '@graphql-tools/merge'
import {parse, visit} from 'graphql'
import * as os from 'os'
import * as path from 'path'

import {
  dedupeTempFolder,
  findQueryMutationInSchema,
  findTypeInSchema,
  getSchema,
  mergeQueryMutationIntoSchema,
  removeQueryMutationFromSchema,
  mergeTypeIntoSchema,
  removeTypeFromSchema,
  getConfiguration,
  findNextAvailableSubfolder,
} from '../utils/merge-helpers'
import print from './print'
import setFilesInSDL from '../utils/set-files-in-sdl'
import stripEmptyQueriesAndMutations from '../utils/strip-empty-queries-and-mutations'

const BLANK_INDEX_TEMPLATE = `
schema @sdl(files: []) {
  query: Query
}
`.trim()

const BLANK_QUERY_TYPE = `
type Query {
  __query: String
}
`.trim()

export default async (
  original: string,
  imported: {
    name: string
    source: string
  },
  options: {
    answers: any
    output: string | null
    silent: boolean
    /** when `false` merge only covers config files and updates @sdl directrive */
    mergeTypes?: boolean
  } = {
    answers: {},
    output: null,
    silent: false,
    mergeTypes: true,
  },
) => {
  // Make sure there is an output directory
  if (!options.answers) options.answers = {}
  if (!options.output)
    options.output = path.join(os.tmpdir(), `stepzen-tmp-${Date.now()}`)
  if (!options.silent) options.silent = false
  if (options.mergeTypes === undefined) options.mergeTypes = true

  // To stop things like
  // C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-config-1638293497187\C:\Users\Darren\AppData\Local\Temp\stepzen-tmp-1638293496286
  options.output = dedupeTempFolder(options.output)

  // Ensure original, importing and output directories exist
  if (!fs.existsSync(original))
    throw new Error(`Cannot find original directory ${original}`)
  if (!fs.existsSync(imported.source))
    throw new Error(`Cannot find imported source directory ${imported.source}`)
  fs.ensureDirSync(options.output)

  // Copy the original into the output.
  fs.copySync(original, options.output)

  // Ensure an index.graphql exists
  const outputIndex = path.join(options.output, 'index.graphql')
  if (!fs.existsSync(outputIndex)) {
    fs.writeFileSync(
      outputIndex,
      options.mergeTypes
        ? // (2022-03-09, vluakshov) Not sure what'd break without the
          // blank Query type, but that's why I do not want to remove it
          // from the default code path.
          BLANK_INDEX_TEMPLATE + BLANK_QUERY_TYPE
        : // In the non-default code path that does NOT merge types
          // the blank Query type causes explicit problems
          // (https://github.com/steprz/stepzen-cli/issues/482).
          BLANK_INDEX_TEMPLATE,
    )
  }

  const targetSubfolder = findNextAvailableSubfolder(original, imported.name)

  if (options.mergeTypes) {
    const merged = mergeTypeDefs([
      await getSchema(options.output),
      await getSchema(imported.source),
    ])

    let queries: any[] = []
    let mutations: any[] = []
    let types: any[] = []

    visit(merged, {
      ObjectTypeDefinition(node) {
        if (node.name.value === 'Query') queries = queries.concat(node.fields)
        else if (node.name.value === 'Mutation')
          mutations = mutations.concat(node.fields)
        else types = types.concat(node)
      },
    })

    const details = {
      original: glob.sync('**/*.graphql', {cwd: options.output}).map(file => {
        const content = fs.readFileSync(`${options.output}/${file}`, 'utf8')
        return {ast: parse(content), file}
      }),
      imported: glob.sync('**/*.graphql', {cwd: imported.source}).map(file => {
        const content = fs.readFileSync(`${imported.source}/${file}`, 'utf8')
        return {ast: parse(content), file}
      }),
    }

    // Merge Queries and Mutations
    for (const type of [...queries, ...mutations]) {
      const isInOriginal = findQueryMutationInSchema(
        type.name.value,
        details.original,
      )
      const isInImported = findQueryMutationInSchema(
        type.name.value,
        details.imported,
      )

      if (isInOriginal && isInImported) {
        details.original = mergeQueryMutationIntoSchema(type, details.original)
        details.imported = removeQueryMutationFromSchema(
          type.name.value,
          details.imported,
        )
      }
    }

    // Merge Types
    for (const type of types) {
      const isInOriginal = findTypeInSchema(type.name.value, details.original)
      const isInImported = findTypeInSchema(type.name.value, details.imported)

      if (isInOriginal && isInImported) {
        details.original = mergeTypeIntoSchema(type, details.original)
        details.imported = removeTypeFromSchema(
          type.name.value,
          details.imported,
        )
      }
    }

    // Clean up the files. Remove empty Query / Mutation types, filter out now-empty files
    const cleaned = {
      original: details.original
        .map(item => ({
          ...item,
          ast: stripEmptyQueriesAndMutations(item.ast),
        }))
        .filter(item => item.ast.definitions.length > 0),
      imported: details.imported
        .map(item => ({
          ...item,
          ast: stripEmptyQueriesAndMutations(item.ast),
        }))
        .filter(item => item.ast.definitions.length > 0),
    }

    // Write the files to the output directory
    cleaned.original.forEach((a: any) => {
      // eslint-disable-next-line
      const file = path.join(options.output as any, a.file)
      const deduped = dedupeTempFolder(file)

      fs.ensureFileSync(deduped)
      fs.writeFileSync(deduped, print(a.ast))
    })

    cleaned.imported.forEach(a => {
      // eslint-disable-next-line
      const file = path.join(options.output as any, targetSubfolder, a.file)
      const deduped = dedupeTempFolder(file)

      fs.ensureFileSync(deduped)
      fs.writeFileSync(deduped, print(a.ast))
    })
  } else {
    // Write the files to the output directory
    fs.copySync(original, options.output)
    glob.sync('**/*.graphql', {cwd: imported.source}).forEach(relativePath => {
      const importedFullPath = path.join(imported.source, relativePath)
      const targetFullPath = path.join(
        options.output!,
        targetSubfolder,
        relativePath,
      )
      fs.ensureDirSync(path.dirname(targetFullPath))
      fs.copyFileSync(importedFullPath, targetFullPath)
    })
  }

  // Make sure all files are referenced in @sdl
  setFilesInSDL(options.output)

  // Generate configuration
  const config = await getConfiguration(
    [options.output, imported.source],
    options.silent,
    options.answers,
  )
  if (config) {
    const configFile = path.join(options.output, 'config.yaml')
    fs.writeFileSync(configFile, config as string)
  }

  // Return a merged schema!
  return options.output
}
