import {BREAK, GraphQLSchema, visit} from 'graphql'
import {buildSchema} from 'graphql/utilities'
import fetch from 'node-fetch'
import * as fs from 'fs-extra'
import * as glob from 'glob'
import * as os from 'os'
import * as path from 'path'
import {replace} from 'lodash'

import {cloneDeep} from '../utils/graphql-helpers'
import {STEPZEN_DOMAIN} from './constants'

import configure from '../actions/configure'
import transpile from '../actions/transpile'

export const dedupeTempFolder = (dirpath: string) => {
  do {
    dirpath = replace(dirpath, os.tmpdir(), '')
  } while (dirpath.includes(os.tmpdir()))

  dirpath = path.join(os.tmpdir(), dirpath)

  return dirpath
}

export const findNextAvailableSubfolder = (folder: string, name: string) => {
  let subfolder = name
  let counter = 1
  while (fs.existsSync(path.join(folder, subfolder))) {
    const suffix = `${counter++}`.padStart(2, '0')
    subfolder = `${name}-${suffix}`
  }

  return subfolder
}

export const findQueryMutationInSchema = (
  name: string,
  files: any,
): Boolean => {
  for (const file of files) {
    let found = false
    visit(file.ast, {
      FieldDefinition(node) {
        if (node.name.value === name) {
          found = true
          return BREAK
        }
      },
    })
    if (found) return true
  }
  return false
}

export const findTypeInSchema = (name: string, files: any): Boolean => {
  for (const file of files) {
    let found = false
    visit(file.ast, {
      ObjectTypeDefinition(node) {
        if (node.name.value === name) {
          found = true
          return BREAK
        }
      },
    })
    if (found) return true
  }
  return false
}

export const getConfiguration = async (
  directories: string[],
  silent: boolean = false,
  answers: any = {},
): Promise<string | boolean> => {
  const tmp = path.join(os.tmpdir(), `stepzen-tmp-config-${Date.now()}`)
  fs.ensureDirSync(tmp)

  for (const directory of directories) {
    const configs = [
      ...glob.sync('**/config.yaml', {cwd: directory}),
      ...glob.sync('**/stepzen.config.json', {cwd: directory}),
    ]

    for (const config of configs) {
      const configFolder = path.join(directory, config)

      let writeFolder = path.join(tmp, directory, config)
      writeFolder = dedupeTempFolder(writeFolder)

      const content = fs.readFileSync(configFolder, 'utf8')

      fs.ensureFileSync(writeFolder)
      fs.writeFileSync(writeFolder, content)
    }
  }

  const configuration = await configure(tmp, silent, answers)
  fs.removeSync(tmp)
  return configuration
}

export const getExtensions = async (): Promise<string> => {
  const domain = STEPZEN_DOMAIN.replace('.io', '.net')
  const response = await fetch(`https://www.${domain}/directives.graphql`)
  const text = await response.text()
  return text
}

export const getSchema = async (directory: string): Promise<GraphQLSchema> => {
  const extensions = await getExtensions()
  const transpiled = await transpile(directory)
  return buildSchema(`${extensions}${os.EOL}${transpiled.schema}`)
}

export const mergeQueryMutationIntoSchema = (type: any, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        FieldDefinition(node) {
          if (node.name.value === type.name.value) {
            const directives = cloneDeep(type.directives)
            const mutated: any = cloneDeep(node)
            mutated.directives = directives
            return mutated
          }
        },
      }),
    }
  })
  return files
}

export const mergeTypeIntoSchema = (type: any, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        ObjectTypeDefinition(node) {
          if (node.name.value === type.name.value) {
            const directives = cloneDeep(type.directives)
            const fields = cloneDeep(type.fields)
            const mutated: any = cloneDeep(node)
            mutated.directives = directives
            mutated.fields = fields
            return mutated
          }
        },
      }),
    }
  })
  return files
}

export const removeQueryMutationFromSchema = (name: string, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        FieldDefinition(node) {
          if (node.name.value === name) {
            return null
          }
        },
      }),
    }
  })
  return files
}

export const removeTypeFromSchema = (name: string, files: any) => {
  files = files.map((file: any) => {
    return {
      ...file,
      ast: visit(file.ast, {
        ObjectTypeDefinition(node) {
          if (node.name.value === name) {
            return null
          }
        },
      }),
    }
  })
  return files
}
