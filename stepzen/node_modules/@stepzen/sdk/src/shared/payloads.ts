// Copyright (c) 2020,2021,2022, StepZen, Inc.

// This file contains helpers that zip a file or directory

import * as archiver from 'archiver'
import * as debug from 'debug'
import * as FormData from 'form-data'
import * as fs from 'fs'
import * as glob from 'glob'
import * as os from 'os'
import * as path from 'path'

type YamlPayload = FormData
type ZipPayload = FormData

// This function takes a (yaml) file path
// and creates a FormData payload, containing the yaml content as 'yaml'
export const generateYamlPayload = async (
  file: string | undefined,
): Promise<YamlPayload> => {
  return new Promise((resolve, reject) => {
    const payload = new FormData()

    if (file) {
      if (!fs.existsSync(file)) {
        reject(new Error(`File does not exist: ${file}`))
      }
      const content = fs.readFileSync(file, 'utf8')
      debug('stepzen:generate-yaml-payload')(content)
      payload.append('yaml', fs.readFileSync(file))
      resolve(payload)
    } else {
      reject(new Error('File not specified'))
    }
  })
}

// This function takes a directory path, and optional data object,
// and creates a FormData payload, containing the directory contents as 'zip',
// and any other items in the data object.
export const generateZipPayload = async (
  directory: string | undefined,
  data: object | undefined,
  filters: RegExp[],
): Promise<ZipPayload> => {
  return new Promise((resolve, reject) => {
    const payload = new FormData()

    if (data) {
      for (const [key, value] of Object.entries(data)) {
        payload.append(key, value)
      }
    }

    // Store it in /tmp. Create a WriteStream
    const filepath = path.join(os.tmpdir(), `stepzen-payload-${Date.now()}.zip`)
    const output = fs.createWriteStream(filepath)

    // We're making a zip file
    const archive = archiver('zip', {
      zlib: {level: 9},
    })

    // We're piping it to the WriteStream
    archive.pipe(output)

    // If we've specified a directory, add it to the archive
    if (directory) {
      if (!fs.existsSync(directory)) {
        reject(new Error(`Directory does not exist: ${directory}`))
      }

      // Get all the files in the directory (and all subdirectories).
      const allFiles = glob.sync('**', {cwd: directory})

      // Loop through each file, because we want to filter them
      // We add them manually, because when we use glob, it embeds
      // a full path, and we want everything to explicitly
      // start at the root of the archive.
      allFiles.forEach(file => {
        const include = filters.some(filter => file.match(filter))

        if (include) {
          debug('stepzen:archive')(file)
          archive.file(path.join(directory, file), {name: file})
        }
      })
    }

    // Once we're done, append a ReadStream to the tmp file
    output.on('close', () => {
      const stream = fs.createReadStream(filepath)
      payload.append('zip', stream)
      // Remove the temporary zip
      stream.on('close', () => {
        fs.unlinkSync(filepath)
      })
      // This is where we return the payload
      resolve(payload)
    })

    // Archive the file or directory
    archive.finalize()
  })
}
