// Copyright (c) 2020,2021,2022, StepZen, Inc.

import * as path from 'path'
import accountCommand from './commands/account'
import authenticate from './commands/authenticate'
import deploy from './commands/deploy'
import {SDKConfiguration, StepZenAccount} from './shared/types'
import list from './commands/list'
import upload from './commands/upload'

export * from './shared/types'

export const init = (sdkConfig: SDKConfiguration) => {
  const defaults = {
    domain: process.env.STEPZEN_DOMAIN || 'stepzen.io',
    server: process.env.STEPZEN_SERVER_URL || 'https://{account}.stepzen.io',
  }

  return {
    verify: (account: string, adminkey: string) => {
      return authenticate(
        {
          account,
          adminkey,
          server: defaults.server.replace('{account}', account),
          domain: defaults.domain,
        },
        sdkConfig,
      )
    },
    client: async (
      options: Pick<StepZenAccount, 'account' | 'adminkey'> &
        Partial<StepZenAccount>,
    ) => {
      if (!options.account) {
        throw new Error('You must provide an account.')
      }

      if (!options.adminkey) {
        throw new Error('You must provide an admin key.')
      }

      const account: StepZenAccount = {
        ...defaults,
        ...options,
      }

      account.server = account.server.replace('{account}', options.account)
      const authorised = await authenticate(account, sdkConfig)

      if (!authorised) {
        throw new Error('Your credentials are invalid.')
      }

      return {
        account: () => {
          return accountCommand(account, sdkConfig)
        },
        deploy: (
          destination: string,
          properties: {
            configurationsets?: string[]
            schema: string
          },
        ) => {
          return deploy({destination, ...properties}, account, sdkConfig)
        },
        list: {
          configurationsets: async () => {
            return list({type: 'configurationsets'}, account, sdkConfig)
          },
          schemas: async () => {
            return list({type: 'schemas'}, account, sdkConfig)
          },
        },
        upload: {
          configurationset: async (destination: string, file: string) => {
            return upload(
              {type: 'configurationset', destination, file},
              account,
              sdkConfig,
            )
          },
          schema: async (destination: string, directory: string) => {
            return upload(
              {type: 'schema', destination, directory},
              account,
              sdkConfig,
            )
          },
        },
      }
    },
  }
}

// a helper type to unwrap Promise<U> into U
type PromisedType<T> = T extends Promise<infer U> ? U : T

export type SDK = ReturnType<typeof init>
export type SDKClient = PromisedType<ReturnType<SDK['client']>>

/**
 * The default SDK instance that does not know the name of the app using the SDK.
 * It tries to guess the app name from `process.argv`
 *
 * @deprecated use the init({appName: 'my-app/1.2.3'}) method to initialis an SDK instance
 */
const stepzen: SDK = init({
  // For legacy apps use the script name (e.g. `index.js` as the app name)
  // Fallback to `node` if this file is imported into an interactive node shell
  appName: path.basename(process.argv[1] || process.argv[0]),
})

export default stepzen

// Hack: support both ESM-style imports: `import stepzen from '@stepzen/sdk'`
// and keep the backwards-compat with CJS-style imports: `const stepzen = require('@stepzen/sdk')`
// NOTE: if at any point in the future there is a name collision between `stepzen` and ES exports
// this hack will break
module.exports = {...module.exports, ...stepzen}
