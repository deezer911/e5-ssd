"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateZipPayload = exports.generateYamlPayload = void 0;
// This file contains helpers that zip a file or directory
const archiver = require("archiver");
const debug = require("debug");
const FormData = require("form-data");
const fs = require("fs");
const glob = require("glob");
const os = require("os");
const path = require("path");
// This function takes a (yaml) file path
// and creates a FormData payload, containing the yaml content as 'yaml'
const generateYamlPayload = async (file) => {
    return new Promise((resolve, reject) => {
        const payload = new FormData();
        if (file) {
            if (!fs.existsSync(file)) {
                reject(new Error(`File does not exist: ${file}`));
            }
            const content = fs.readFileSync(file, 'utf8');
            debug('stepzen:generate-yaml-payload')(content);
            payload.append('yaml', fs.readFileSync(file));
            resolve(payload);
        }
        else {
            reject(new Error('File not specified'));
        }
    });
};
exports.generateYamlPayload = generateYamlPayload;
// This function takes a directory path, and optional data object,
// and creates a FormData payload, containing the directory contents as 'zip',
// and any other items in the data object.
const generateZipPayload = async (directory, data, filters) => {
    return new Promise((resolve, reject) => {
        const payload = new FormData();
        if (data) {
            for (const [key, value] of Object.entries(data)) {
                payload.append(key, value);
            }
        }
        // Store it in /tmp. Create a WriteStream
        const filepath = path.join(os.tmpdir(), `stepzen-payload-${Date.now()}.zip`);
        const output = fs.createWriteStream(filepath);
        // We're making a zip file
        const archive = archiver('zip', {
            zlib: { level: 9 },
        });
        // We're piping it to the WriteStream
        archive.pipe(output);
        // If we've specified a directory, add it to the archive
        if (directory) {
            if (!fs.existsSync(directory)) {
                reject(new Error(`Directory does not exist: ${directory}`));
            }
            // Get all the files in the directory (and all subdirectories).
            const allFiles = glob.sync('**', { cwd: directory });
            // Loop through each file, because we want to filter them
            // We add them manually, because when we use glob, it embeds
            // a full path, and we want everything to explicitly
            // start at the root of the archive.
            allFiles.forEach(file => {
                const include = filters.some(filter => file.match(filter));
                if (include) {
                    debug('stepzen:archive')(file);
                    archive.file(path.join(directory, file), { name: file });
                }
            });
        }
        // Once we're done, append a ReadStream to the tmp file
        output.on('close', () => {
            const stream = fs.createReadStream(filepath);
            payload.append('zip', stream);
            // Remove the temporary zip
            stream.on('close', () => {
                fs.unlinkSync(filepath);
            });
            // This is where we return the payload
            resolve(payload);
        });
        // Archive the file or directory
        archive.finalize();
    });
};
exports.generateZipPayload = generateZipPayload;
//# sourceMappingURL=payloads.js.map